// Compute the size of the algebra R/IR, where I is the zero-dimensional ideal generated by B. 
// Here the coefficient ring R is supposed to be a p-adic quotient ring (because 
// Magma can't compute Groebner bases of p-adic rings) or a finite precision series
// ring over a finite field. 
// In the situations we are interested in, this will be the same as the length 
// of the corresponding O_Cv-module, where Cv is an irreducible component of the
// special fiber of a smooth projective curve over R.

function local_module_length(B)

  my_exponents := func<f, n | IsOne(#Terms(f)) select Exponents(f) else [0:i in [1..n]]>; 
  // Returns the list of exponents if f is a monomial of positive degree
  cond_satisfied := func<I, cond | &or [I[j] lt cond[j]: j in [1..#I]] >; 
  // Checks if the monomial with exponents I is a multiple of the one w exponents cond

  if not IsGroebner(B) then
    B := GroebnerBasis(B);
  end if;
  q0 := B[#B];
  error if TotalDegree(q0) ne 0, "Module is not finite. Try rerunning this computation with
                                                                     higher local precision.";
  //   q0 is an element of R. 
  R := Parent(B[1]);
  v0 := Valuation(BaseRing(R) ! q0); 
  if IsOne(#B) then  
  //      q0 is the unique element of B
    return v0;
  end if;

  if IsZero(v0) then  //    I contains 1
    return 0;
  end if;
  sum := v0;
  pi := UniformizingElement(BaseRing(R));
  n := Rank(R);
  Conditions := [];
  //  start with monomials of total degree 1. They will be initialized below
  TD := 1;
  current_exponents := [[0:i in [1..n]]];
  while true do
    tuples_left := false;
    old_exponents := current_exponents;
    current_exponents := [];
    for i := 1 to #old_exponents do
      I := old_exponents[i];
      //  We add new monomials by increasing the degrees of our current monomials in each 
      //  indeterminate by 1
      for j := 1 to n do
        I[j] +:= 1;
        //    We only add the monomial to our list if it hasn't already been taken care of
        if I notin current_exponents and &and[cond_satisfied(I, cond):cond in Conditions] then  
          Include(~current_exponents, I);
          a := 0;
          r := NormalForm(Monomial(R, I), B);//mod out by B
                  
          //  The following while-loop does the actual work by computing the smallest power a of pi
          //  such that pi ^ a can be expressed using other monomials of equal or lower degree
          while my_exponents(r, n) eq I   do
            a +:= 1;
            r := NormalForm(pi * r, B);
          end while;
          //      if the monomial is in the ideal, all its multiples will be
          if a eq 0 then 
            Append(~Conditions, I);
          else
            tuples_left := true; // still work to do!
            sum +:= a;
          end if;
        end if;  
        I[j] -:= 1;
      end for;
    end for;
    if tuples_left then
      TD +:= 1;
    else
      return sum;  
    end if;  
  end while;
end function;

